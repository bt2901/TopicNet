<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>topicnet.cooking_machine.cubes.controller_cube API documentation</title>
<meta name="description" content="Allows to add `ControllerAgent` (with unknown parameters) to the model, which enables user to
change `tau` during the `_fit` method â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>topicnet.cooking_machine.cubes.controller_cube</code></h1>
</header>
<section id="section-intro">
<p>Allows to add <a title="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent" href="#topicnet.cooking_machine.cubes.controller_cube.ControllerAgent"><code>ControllerAgent</code></a> (with unknown parameters) to the model, which enables user to
change <code>tau</code> during the <code>_fit</code> method.</p>
<p><code>parameters</code> is a dict with four fields:</p>
<h2 id="fields">Fields</h2>
<dl>
<dt><strong><code>reg_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of regularizer. We want to change the tau coefficient of it during training
Note that only one of ("reg_name", "regularizer") should be provided</dd>
<dt><strong><code>regularizer</code></strong> :&ensp;<code>artm.regularizer.Regularizer</code></dt>
<dd>Regularizer object (if we want to add non-existing regularizer to the model)
Note that only one of ("reg_name", "regularizer") should be provided</dd>
<dt><strong><code>score_to_track</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The name of metric which we will track.
We assume that if that metric is 'sort of decreasing', then everything is OK
and we are allowed to change tau coefficient further; otherwise we revert back
to the last "safe" value and stop</p>
<p>More formal definition of "sort of decreasing": if we divide a curve into two parts like so:</p>
<pre><code>##################################### 
#. . . .. . . . ..  . .. . .  ... . # 
#%. . .  . . . .  .. . . . . .  . ..# 
#:t . . . . . . . . . . . . . . .  .# 
# t: . . . . . . . . . . . . . . ...# 
#. %. . . . . . . . . . . . . . .  .# 
#. :t. . . . . . . . .  .  . . . . .# 
#.. ;; . .  . . . .  . . . .  . . ..# 
#  ..t..  . .  . . . . . . . . . . .# 
#. . :t .. . . .  . . . . . . . . ..# 
#. .. t: . . . . . . . . . . . . . .# 
#.   ..S: . . . . . . . . . . . . ..# 
#. . . .:;: . . . . .  . . . . . . .# 
#. . .  . :;;  . . . . . . . . . . .# 
#. . . . .. :%.      nmmMMmmn   .  .# 
# .   . .  . .tt%.ztttt"' '""ttttttt# 
#. . .    . . . '"' . . . . . . . . # 
##################################### 
|                |                  | 
|   left part    |                  | 
           global minimum           | 
                 |     right part   |
</code></pre>
<p>then the right part is no higher than 5% of global minimum
(you can change 5% if you like by adjusting <code>fraction_threshold</code>
in <a title="topicnet.cooking_machine.cubes.controller_cube.is_score_out_of_control" href="#topicnet.cooking_machine.cubes.controller_cube.is_score_out_of_control"><code>is_score_out_of_control()</code></a> function)</p>
<p>If score_to_track is None, then <a title="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent" href="#topicnet.cooking_machine.cubes.controller_cube.ControllerAgent"><code>ControllerAgent</code></a> will never stop
(useful for e.g. decaying coefficients)</p>
</dd>
<dt><strong><code>tau_converter</code></strong> :&ensp;<code>str</code> or <code>callable</code></dt>
<dd>
<p>Notably, def-style functions and lambda functions are allowed
If it is function, then it should accept four arguments:
<code>(initial_tau, prev_tau, cur_iter, user_value)</code>
For example:</p>
<pre><code>&gt;&gt; lambda initial_tau, prev_tau, cur_iter, user_value:
&gt;&gt;     initial_tau if cur_iter % 2 == 0 else 0
</code></pre>
<p>(Note that experiment description might display lambda functions incorrectly;
Try to keep them to a single line or use def-style functions instead)</p>
<pre><code>&gt;&gt; def func(initial_tau, prev_tau, cur_iter, user_value):
&gt;&gt;     relu_grower = user_value * (cur_iter - 8) if cur_iter &gt; 8 else 0
&gt;&gt;     return 0 if cur_iter % 2 else relu_grower
</code></pre>
<p>If it is a string, then it should be an expression consisting of numbers, operations
and variables (four are allowed: <code>initial_tau, prev_tau, cur_iter, user_value</code>)
For example:</p>
<p><code>&gt;&gt; "initial_tau * ((cur_iter + 1) % 2)"</code></p>
<p>or</p>
<p><code>&gt;&gt; "prev_tau * user_value"</code></p>
</dd>
<dt><strong><code>user_value_grid</code></strong> :&ensp;<code>list</code> of <code>numeric</code></dt>
<dd>
<p>Values for user_value variable
When writing <code>tau_converter</code>, you can use user_value variable.</p>
<p>For example:</p>
<pre><code>&gt;&gt; tau_converter: "prev_tau * user_value"
&gt;&gt; user_value_grid: [1, 0.99, 0.95, 0.90, 0.80, 0.5]
</code></pre>
<p>(I know that tau should decay exponentially, but I'm unsure of exact half-life)</p>
<pre><code>&gt;&gt; tau_converter: "prev_tau + user_value"
&gt;&gt; user_value_grid: [50, 100, 150, 200, 250]
</code></pre>
<p>(I know that tau should increase linearly, but I'm unsure of exact speed)</p>
<pre><code>&gt;&gt; def func(initial_tau, prev_tau, cur_iter, user_value):
&gt;&gt;     new_tau = 50 * (cur_iter - user_value) if cur_iter &gt; user_value else 0
&gt;&gt;     return new_tau
&gt;&gt; tau_converter: func
&gt;&gt; user_value_grid: [10, 15, 20, 25, 30]
</code></pre>
<p>(Tau should start with zero, then increase linearly. I don't know when to start this process)</p>
</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>numeric</code></dt>
<dd>Optional (default value is <code>num_iter</code> specified for cube)
Agent will stop changing tau after <code>max_iters</code> iterations
<code>max_iters</code> could be <code>float("NaN")</code> and <code>float("inf")</code> values:
that way agent will continue operating even outside this <a title="topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube" href="#topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube"><code>RegularizationControllerCube</code></a></dd>
</dl>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Allows to add `ControllerAgent` (with unknown parameters) to the model, which enables user to
change `tau` during the `_fit` method.


`parameters` is a dict with four fields:

Fields
------
reg_name: str
    The name of regularizer. We want to change the tau coefficient of it during training
    Note that only one of (&#34;reg_name&#34;, &#34;regularizer&#34;) should be provided
regularizer: artm.regularizer.Regularizer
    Regularizer object (if we want to add non-existing regularizer to the model)
    Note that only one of (&#34;reg_name&#34;, &#34;regularizer&#34;) should be provided
score_to_track: str
    The name of metric which we will track.
    We assume that if that metric is &#39;sort of decreasing&#39;, then everything is OK
    and we are allowed to change tau coefficient further; otherwise we revert back
    to the last &#34;safe&#34; value and stop

    More formal definition of &#34;sort of decreasing&#34;: if we divide a curve into two parts like so:


        ##################################### 
        #. . . .. . . . ..  . .. . .  ... . # 
        #%. . .  . . . .  .. . . . . .  . ..# 
        #:t . . . . . . . . . . . . . . .  .# 
        # t: . . . . . . . . . . . . . . ...# 
        #. %. . . . . . . . . . . . . . .  .# 
        #. :t. . . . . . . . .  .  . . . . .# 
        #.. ;; . .  . . . .  . . . .  . . ..# 
        #  ..t..  . .  . . . . . . . . . . .# 
        #. . :t .. . . .  . . . . . . . . ..# 
        #. .. t: . . . . . . . . . . . . . .# 
        #.   ..S: . . . . . . . . . . . . ..# 
        #. . . .:;: . . . . .  . . . . . . .# 
        #. . .  . :;;  . . . . . . . . . . .# 
        #. . . . .. :%.      nmmMMmmn   .  .# 
        # .   . .  . .tt%.ztttt&#34;&#39; &#39;&#34;&#34;ttttttt# 
        #. . .    . . . &#39;&#34;&#39; . . . . . . . . # 
        ##################################### 
        |                |                  | 
        |   left part    |                  | 
                   global minimum           | 
                         |     right part   | 

    then the right part is no higher than 5% of global minimum
    (you can change 5% if you like by adjusting `fraction_threshold`
     in `is_score_out_of_control` function)

    If score_to_track is None, then `ControllerAgent` will never stop
    (useful for e.g. decaying coefficients)

tau_converter: str or callable
    Notably, def-style functions and lambda functions are allowed
    If it is function, then it should accept four arguments:
        `(initial_tau, prev_tau, cur_iter, user_value)`
    For example:

        &gt;&gt; lambda initial_tau, prev_tau, cur_iter, user_value:
        &gt;&gt;     initial_tau if cur_iter % 2 == 0 else 0

    (Note that experiment description might display lambda functions incorrectly;
     Try to keep them to a single line or use def-style functions instead)

        &gt;&gt; def func(initial_tau, prev_tau, cur_iter, user_value):
        &gt;&gt;     relu_grower = user_value * (cur_iter - 8) if cur_iter &gt; 8 else 0
        &gt;&gt;     return 0 if cur_iter % 2 else relu_grower

    If it is a string, then it should be an expression consisting of numbers, operations
        and variables (four are allowed: `initial_tau, prev_tau, cur_iter, user_value`)
    For example:

    `&gt;&gt; &#34;initial_tau * ((cur_iter + 1) % 2)&#34;`

    or

    `&gt;&gt; &#34;prev_tau * user_value&#34;`

user_value_grid: list of numeric
    Values for user_value variable
    When writing `tau_converter`, you can use user_value variable.

    For example:

        &gt;&gt; tau_converter: &#34;prev_tau * user_value&#34;
        &gt;&gt; user_value_grid: [1, 0.99, 0.95, 0.90, 0.80, 0.5]

    (I know that tau should decay exponentially, but I&#39;m unsure of exact half-life)

        &gt;&gt; tau_converter: &#34;prev_tau + user_value&#34;
        &gt;&gt; user_value_grid: [50, 100, 150, 200, 250]

    (I know that tau should increase linearly, but I&#39;m unsure of exact speed)

        &gt;&gt; def func(initial_tau, prev_tau, cur_iter, user_value):
        &gt;&gt;     new_tau = 50 * (cur_iter - user_value) if cur_iter &gt; user_value else 0
        &gt;&gt;     return new_tau
        &gt;&gt; tau_converter: func
        &gt;&gt; user_value_grid: [10, 15, 20, 25, 30]

    (Tau should start with zero, then increase linearly. I don&#39;t know when to start this process)

max_iter: numeric
    Optional (default value is `num_iter` specified for cube)
    Agent will stop changing tau after `max_iters` iterations
    `max_iters` could be `float(&#34;NaN&#34;)` and `float(&#34;inf&#34;)` values:
    that way agent will continue operating even outside this `RegularizationControllerCube`
&#34;&#34;&#34;  # noqa: W291

from .base_cube import BaseCube
from ..rel_toolbox_lite import count_vocab_size, handle_regularizer

import numexpr as ne
import warnings
from dill.source import getsource
from copy import deepcopy
import numpy as np


W_HALT_CONTROL = &#34;Process of dynamically changing tau was stopped at {} iteration&#34;
W_MAX_ITERS = &#34;Maximum number of iterations is exceeded; turning off&#34;


def is_score_out_of_control(model, score_name, fraction_threshold=0.05):
    &#34;&#34;&#34;
    Returns True if score isn&#39;t &#39;sort of decreasing&#39; anymore.

    See docstring for RegularizationControllerCube for details

    Parameters
    ----------
    model : TopicModel
    score_name : str or None
    fraction_threshold : float

    Returns
    -------
    bool

    &#34;&#34;&#34;

    if score_name not in model.scores:  # case of None is handled here as well
        return False

    vals = model.scores[score_name]
    if len(vals) == 0:
        return False

    idxmin = np.argmin(vals)

    if idxmin == len(vals):  # score is monotonically decreasing
        return False
    maxval = max(vals[idxmin:])
    minval = vals[idxmin]
    answer = ((maxval - minval)/abs(minval) - 1.0) &gt; fraction_threshold
    if answer:
        msg = (f&#34;Score {score_name} is too high: during training the value {maxval}&#34;
               f&#34; passed a treshold of {(1 + fraction_threshold) * minval}&#34;
               f&#34; (estimate is based on {idxmin} iteration)&#34;)
        warnings.warn(msg)
    return answer


class ControllerAgent:
    &#34;&#34;&#34;
    Allows to change `tau` during the `_fit` method.

    Each `TopicModel` has a `.callbacks` attribute.
    This is a list consisting of various `ControllerAgent`s.
    Each agent is described by:

    * reg_name: the name of regularizer having `tau` which needs to be changed
    * score_to_track: score providing control of the callback execution
    * tau_converter: function or string describing how to get new `tau` from old `tau`
    * local_dict: dictionary containing values of several variables,
            most notably, `user_value`
    * is_working:
            if True, agent will attempt to change tau until something breaks.
            if False, agent will assume that something had been broken and will
            revert to the last known safe value (without trying to change anything further)

    See top-level docstring for details.
    &#34;&#34;&#34;
    def __init__(self, reg_name, score_to_track, tau_converter, max_iters, local_dict=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        reg_name : str
        score_to_track : str, list of str or None
        tau_converter : callable or str
        local_dict : dict
        max_iters : int or float
            Agent will stop changing tau after `max_iters` iterations
            `max_iters` could be `float(&#34;NaN&#34;)` and `float(&#34;inf&#34;)` values:
            that way agent will continue operating even outside this `RegularizationControllerCube`
        &#34;&#34;&#34;
        if local_dict is None:
            local_dict = dict()

        self.reg_name = reg_name
        self.tau_converter = tau_converter
        if isinstance(score_to_track, list):
            self.score_to_track = score_to_track
        elif isinstance(score_to_track, str):
            self.score_to_track = [score_to_track]
        else:
            self.score_to_track = []

        self.is_working = True
        self.local_dict = local_dict
        self.tau_history = []
        self.max_iters = max_iters

    def _convert_tau(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        if isinstance(self.tau_converter, str):
            new_tau = ne.evaluate(self.tau_converter, local_dict=self.local_dict)
            # numexpr returns np.ndarray (which is a scalar in our case)
            new_tau = float(new_tau)
        else:
            new_tau = self.tau_converter(**self.local_dict)
        return new_tau

    def _find_safe_tau(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        if len(self.tau_history) &lt; 2:
            warnings.warn(&#34;Reverting tau to 0&#34;)
            safe_tau = 0
        else:
            safe_tau = self.tau_history[-2]
        return safe_tau

    def invoke(self, model, cur_iter):
        &#34;&#34;&#34;
        Attempts to change tau if `is_working == True`. Otherwise, keeps to the last safe value.

        Parameters
        ----------
        model : TopicModel
        cur_iter : int
            Note that zero means &#34;cube just started&#34;, not &#34;the model is brand new&#34;

        &#34;&#34;&#34;
        current_tau = model.regularizers[self.reg_name].tau
        self.tau_history.append(current_tau)
        self.local_dict[&#34;prev_tau&#34;] = current_tau
        self.local_dict[&#34;cur_iter&#34;] = cur_iter

        if &#34;initial_tau&#34; not in self.local_dict:
            self.local_dict[&#34;initial_tau&#34;] = current_tau

        if self.is_working and len(self.tau_history) &gt; self.max_iters:
            warnings.warn(W_MAX_ITERS)
            self.is_working = False

        if self.is_working:
            should_stop = any(
                is_score_out_of_control(model, score) for score in self.score_to_track
            )
            if should_stop:
                warnings.warn(W_HALT_CONTROL.format(len(self.tau_history)))
                self.is_working = False
                model.regularizers[self.reg_name].tau = self._find_safe_tau()
            else:
                model.regularizers[self.reg_name].tau = self._convert_tau()


class RegularizationControllerCube(BaseCube):
    def __init__(self, num_iter: int, parameters,
                 reg_search=&#39;grid&#39;, use_relative_coefficients: bool = True, strategy=None,
                 tracked_score_function=None, verbose: bool = False, separate_thread: bool = True):
        &#34;&#34;&#34;
        Initialize stage. Checks params and update internal attributes.

        Parameters
        ----------
        num_iter : int
            number of iterations or method
        parameters : list[dict] or dict
            regularizers params
            each dict should contain the following fields: 
                (&#34;reg_name&#34; or &#34;regularizer&#34;),
                &#34;score_to_track&#34; (optional),
                &#34;tau_converter&#34;,
                &#34;user_value_grid&#34;
                See top-level docstring for details.
            Examples:

                    &gt;&gt;  {&#34;regularizer&#34;: artm.regularizers.&lt;...&gt;,
                    &gt;&gt;   &#34;score_to_track&#34;: &#34;PerplexityScore@all&#34;,
                    &gt;&gt;   &#34;tau_converter&#34;: &#34;prev_tau * user_value&#34;,
                    &gt;&gt;   &#34;user_value_grid&#34;: [0.5, 1, 2]}


            -----------

                    &gt;&gt;  {&#34;reg_name&#34;: &#34;decorrelator_for_ngramms&#34;,
                    &gt;&gt;   &#34;score_to_track&#34;: None,
                    &gt;&gt;   &#34;tau_converter&#34;: (
                    &gt;&gt;       lambda initial_tau, prev_tau, cur_iter, user_value:
                    &gt;&gt;       initial_tau * (cur_iter % 2) + user_value
                    &gt;&gt;   )
                    &gt;&gt;   &#34;user_value_grid&#34;: [0, 1]}

        reg_search : str
            &#34;grid&#34;, &#34;pair&#34;, &#34;add&#34; or &#34;mul&#34;. 
            &#34;pair&#34; for elementwise grid search in the case of several regularizers 
            &#34;grid&#34; for the fullgrid search in the case of several regularizers 
            &#34;add&#34; and &#34;mul&#34; for the ariphmetic and geometric progression
            respectively for PerplexityStrategy 
            (Default value = &#34;grid&#34;)
        use_relative_coefficients : bool
            forces the regularizer coefficient to be in relative form
            i.e. normalized over collection properties
        strategy : BaseStrategy
            optimization approach (Default value = None)
        tracked_score_function : str ot callable
            optimizable function for strategy (Default value = None)
        verbose : bool
            visualization flag (Default value = False)

        &#34;&#34;&#34;  # noqa: W291
        super().__init__(num_iter=num_iter, action=&#39;reg_controller&#39;,
                         reg_search=reg_search, strategy=strategy, verbose=verbose,
                         tracked_score_function=tracked_score_function,
                         separate_thread=separate_thread)
        self._relative = use_relative_coefficients
        self.data_stats = None
        self.raw_parameters = parameters
        if isinstance(parameters, dict):
            parameters = [parameters]
        self._convert_parameters(parameters)

    def _convert_parameters(self, all_parameters):
        &#34;&#34;&#34;

        Parameters
        ----------
        all_parameters : list of dict

        &#34;&#34;&#34;
        for params_dict in all_parameters:
            assert (&#34;reg_name&#34; in params_dict) != (&#34;regularizer&#34; in params_dict)
            if &#34;regularizer&#34; in params_dict:
                assert params_dict[&#34;regularizer&#34;].tau is not None

        self.parameters = [
            {
                &#34;object&#34;: {
                    &#34;reg_name&#34;: params_dict.get(&#34;reg_name&#34;, None),
                    &#34;regularizer&#34;: params_dict.get(&#34;regularizer&#34;, None),
                    &#34;score_to_track&#34;: params_dict.get(&#34;score_to_track&#34;, None),
                    &#34;tau_converter&#34;: params_dict[&#34;tau_converter&#34;],
                    &#34;local_dict&#34;: {&#34;user_value&#34;: None},
                    &#34;max_iters&#34;: params_dict.get(&#34;max_iters&#34;, self.num_iter)
                },
                &#34;field&#34;: &#34;callback&#34;,
                &#34;values&#34;: params_dict.get(&#39;user_value_grid&#39;, [0])
            }
            for params_dict in all_parameters
        ]

    def apply(self, topic_model, one_model_parameter, dictionary=None, model_id=None):
        &#34;&#34;&#34;
        Applies regularizers and controller agents to model

        Parameters
        ----------
        topic_model : TopicModel
        one_model_parameter : list or tuple
        dictionary : Dictionary
            (Default value = None)
        model_id : str
            (Default value = None)

        Returns
        -------
        TopicModel

        &#34;&#34;&#34;
        new_model = topic_model.clone(model_id)
        new_model.parent_model_id = topic_model.model_id

        modalities = dict()
        if self._relative:
            modalities = new_model.class_ids
            if self.data_stats is None:
                self.data_stats = count_vocab_size(dictionary, modalities)

        for (agent_blueprint_template, field_name, current_user_value) in one_model_parameter:
            agent_blueprint = dict(agent_blueprint_template)
            if agent_blueprint[&#34;reg_name&#34;] is None:
                regularizer = agent_blueprint[&#34;regularizer&#34;]
                new_regularizer = deepcopy(regularizer)
                handle_regularizer(
                    self._relative,
                    new_model,
                    new_regularizer,
                    self.data_stats,
                )
                agent_blueprint[&#34;reg_name&#34;] = new_regularizer.name
            else:
                if agent_blueprint[&#39;reg_name&#39;] not in new_model.regularizers.data:
                    error_msg = (f&#34;Regularizer {agent_blueprint[&#39;reg_name&#39;]} does not exist. &#34;
                                 f&#34;Cannot be modified.&#34;)
                    raise ValueError(error_msg)

            agent_blueprint[&#39;local_dict&#39;][&#39;user_value&#39;] = current_user_value
            # ControllerAgent needs only reg_name in constructor
            agent_blueprint.pop(&#34;regularizer&#34;)
            agent = ControllerAgent(**agent_blueprint)
            new_model.callbacks.append(agent)
        return new_model

    def get_jsonable_from_parameters(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        jsonable_parameters = []

        for one_model_parameters in self.raw_parameters:
            one_jsonable = dict(one_model_parameters)
            converter = one_model_parameters[&#39;tau_converter&#39;]

            if not isinstance(converter, str):
                try:
                    # not always works, but this is not important
                    one_jsonable[&#34;tau_converter&#34;] = str(getsource(converter))
                except (TypeError, OSError):
                    # OSError: may arise if working in Jupyter Notebook
                    one_jsonable[&#34;tau_converter&#34;] = &#34;&lt;NOT AVAILABLE&gt;&#34;

            jsonable_parameters.append(one_jsonable)

        return jsonable_parameters</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="topicnet.cooking_machine.cubes.controller_cube.is_score_out_of_control"><code class="name flex">
<span>def <span class="ident">is_score_out_of_control</span></span>(<span>model, score_name, fraction_threshold=0.05)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns True if score isn't 'sort of decreasing' anymore.</p>
<p>See docstring for RegularizationControllerCube for details</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>TopicModel</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>score_name</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fraction_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_score_out_of_control(model, score_name, fraction_threshold=0.05):
    &#34;&#34;&#34;
    Returns True if score isn&#39;t &#39;sort of decreasing&#39; anymore.

    See docstring for RegularizationControllerCube for details

    Parameters
    ----------
    model : TopicModel
    score_name : str or None
    fraction_threshold : float

    Returns
    -------
    bool

    &#34;&#34;&#34;

    if score_name not in model.scores:  # case of None is handled here as well
        return False

    vals = model.scores[score_name]
    if len(vals) == 0:
        return False

    idxmin = np.argmin(vals)

    if idxmin == len(vals):  # score is monotonically decreasing
        return False
    maxval = max(vals[idxmin:])
    minval = vals[idxmin]
    answer = ((maxval - minval)/abs(minval) - 1.0) &gt; fraction_threshold
    if answer:
        msg = (f&#34;Score {score_name} is too high: during training the value {maxval}&#34;
               f&#34; passed a treshold of {(1 + fraction_threshold) * minval}&#34;
               f&#34; (estimate is based on {idxmin} iteration)&#34;)
        warnings.warn(msg)
    return answer</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent"><code class="flex name class">
<span>class <span class="ident">ControllerAgent</span></span>
<span>(</span><span>reg_name, score_to_track, tau_converter, max_iters, local_dict=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Allows to change <code>tau</code> during the <code>_fit</code> method.</p>
<p>Each <code>TopicModel</code> has a <code>.callbacks</code> attribute.
This is a list consisting of various <a title="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent" href="#topicnet.cooking_machine.cubes.controller_cube.ControllerAgent"><code>ControllerAgent</code></a>s.
Each agent is described by:</p>
<ul>
<li>reg_name: the name of regularizer having <code>tau</code> which needs to be changed</li>
<li>score_to_track: score providing control of the callback execution</li>
<li>tau_converter: function or string describing how to get new <code>tau</code> from old <code>tau</code></li>
<li>local_dict: dictionary containing values of several variables,
most notably, <code>user_value</code></li>
<li>is_working:
if True, agent will attempt to change tau until something breaks.
if False, agent will assume that something had been broken and will
revert to the last known safe value (without trying to change anything further)</li>
</ul>
<p>See top-level docstring for details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reg_name</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>score_to_track</code></strong> :&ensp;<code>str</code>, <code>list</code> of <code>str</code> or <code>None</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>tau_converter</code></strong> :&ensp;<code>callable</code> or <code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>local_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_iters</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Agent will stop changing tau after <code>max_iters</code> iterations
<code>max_iters</code> could be <code>float("NaN")</code> and <code>float("inf")</code> values:
that way agent will continue operating even outside this <a title="topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube" href="#topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube"><code>RegularizationControllerCube</code></a></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ControllerAgent:
    &#34;&#34;&#34;
    Allows to change `tau` during the `_fit` method.

    Each `TopicModel` has a `.callbacks` attribute.
    This is a list consisting of various `ControllerAgent`s.
    Each agent is described by:

    * reg_name: the name of regularizer having `tau` which needs to be changed
    * score_to_track: score providing control of the callback execution
    * tau_converter: function or string describing how to get new `tau` from old `tau`
    * local_dict: dictionary containing values of several variables,
            most notably, `user_value`
    * is_working:
            if True, agent will attempt to change tau until something breaks.
            if False, agent will assume that something had been broken and will
            revert to the last known safe value (without trying to change anything further)

    See top-level docstring for details.
    &#34;&#34;&#34;
    def __init__(self, reg_name, score_to_track, tau_converter, max_iters, local_dict=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        reg_name : str
        score_to_track : str, list of str or None
        tau_converter : callable or str
        local_dict : dict
        max_iters : int or float
            Agent will stop changing tau after `max_iters` iterations
            `max_iters` could be `float(&#34;NaN&#34;)` and `float(&#34;inf&#34;)` values:
            that way agent will continue operating even outside this `RegularizationControllerCube`
        &#34;&#34;&#34;
        if local_dict is None:
            local_dict = dict()

        self.reg_name = reg_name
        self.tau_converter = tau_converter
        if isinstance(score_to_track, list):
            self.score_to_track = score_to_track
        elif isinstance(score_to_track, str):
            self.score_to_track = [score_to_track]
        else:
            self.score_to_track = []

        self.is_working = True
        self.local_dict = local_dict
        self.tau_history = []
        self.max_iters = max_iters

    def _convert_tau(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        if isinstance(self.tau_converter, str):
            new_tau = ne.evaluate(self.tau_converter, local_dict=self.local_dict)
            # numexpr returns np.ndarray (which is a scalar in our case)
            new_tau = float(new_tau)
        else:
            new_tau = self.tau_converter(**self.local_dict)
        return new_tau

    def _find_safe_tau(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        if len(self.tau_history) &lt; 2:
            warnings.warn(&#34;Reverting tau to 0&#34;)
            safe_tau = 0
        else:
            safe_tau = self.tau_history[-2]
        return safe_tau

    def invoke(self, model, cur_iter):
        &#34;&#34;&#34;
        Attempts to change tau if `is_working == True`. Otherwise, keeps to the last safe value.

        Parameters
        ----------
        model : TopicModel
        cur_iter : int
            Note that zero means &#34;cube just started&#34;, not &#34;the model is brand new&#34;

        &#34;&#34;&#34;
        current_tau = model.regularizers[self.reg_name].tau
        self.tau_history.append(current_tau)
        self.local_dict[&#34;prev_tau&#34;] = current_tau
        self.local_dict[&#34;cur_iter&#34;] = cur_iter

        if &#34;initial_tau&#34; not in self.local_dict:
            self.local_dict[&#34;initial_tau&#34;] = current_tau

        if self.is_working and len(self.tau_history) &gt; self.max_iters:
            warnings.warn(W_MAX_ITERS)
            self.is_working = False

        if self.is_working:
            should_stop = any(
                is_score_out_of_control(model, score) for score in self.score_to_track
            )
            if should_stop:
                warnings.warn(W_HALT_CONTROL.format(len(self.tau_history)))
                self.is_working = False
                model.regularizers[self.reg_name].tau = self._find_safe_tau()
            else:
                model.regularizers[self.reg_name].tau = self._convert_tau()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent.invoke"><code class="name flex">
<span>def <span class="ident">invoke</span></span>(<span>self, model, cur_iter)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to change tau if <code>is_working == True</code>. Otherwise, keeps to the last safe value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>TopicModel</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cur_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Note that zero means "cube just started", not "the model is brand new"</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def invoke(self, model, cur_iter):
    &#34;&#34;&#34;
    Attempts to change tau if `is_working == True`. Otherwise, keeps to the last safe value.

    Parameters
    ----------
    model : TopicModel
    cur_iter : int
        Note that zero means &#34;cube just started&#34;, not &#34;the model is brand new&#34;

    &#34;&#34;&#34;
    current_tau = model.regularizers[self.reg_name].tau
    self.tau_history.append(current_tau)
    self.local_dict[&#34;prev_tau&#34;] = current_tau
    self.local_dict[&#34;cur_iter&#34;] = cur_iter

    if &#34;initial_tau&#34; not in self.local_dict:
        self.local_dict[&#34;initial_tau&#34;] = current_tau

    if self.is_working and len(self.tau_history) &gt; self.max_iters:
        warnings.warn(W_MAX_ITERS)
        self.is_working = False

    if self.is_working:
        should_stop = any(
            is_score_out_of_control(model, score) for score in self.score_to_track
        )
        if should_stop:
            warnings.warn(W_HALT_CONTROL.format(len(self.tau_history)))
            self.is_working = False
            model.regularizers[self.reg_name].tau = self._find_safe_tau()
        else:
            model.regularizers[self.reg_name].tau = self._convert_tau()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube"><code class="flex name class">
<span>class <span class="ident">RegularizationControllerCube</span></span>
<span>(</span><span>num_iter, parameters, reg_search='grid', use_relative_coefficients=True, strategy=None, tracked_score_function=None, verbose=False, separate_thread=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Abstract class for all cubes.</p>
<p>Initialize stage. Checks params and update internal attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>number of iterations or method</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list</code>[<code>dict</code>] or <code>dict</code></dt>
<dd>
<p>regularizers params
each dict should contain the following fields:
("reg_name" or "regularizer"),
"score_to_track" (optional),
"tau_converter",
"user_value_grid"
See top-level docstring for details.
Examples:</p>
<pre><code>    &gt;&gt;  {"regularizer": artm.regularizers.&lt;...&gt;,
    &gt;&gt;   "score_to_track": "PerplexityScore@all",
    &gt;&gt;   "tau_converter": "prev_tau * user_value",
    &gt;&gt;   "user_value_grid": [0.5, 1, 2]}
</code></pre>
<hr>
<pre><code>    &gt;&gt;  {"reg_name": "decorrelator_for_ngramms",
    &gt;&gt;   "score_to_track": None,
    &gt;&gt;   "tau_converter": (
    &gt;&gt;       lambda initial_tau, prev_tau, cur_iter, user_value:
    &gt;&gt;       initial_tau * (cur_iter % 2) + user_value
    &gt;&gt;   )
    &gt;&gt;   "user_value_grid": [0, 1]}
</code></pre>
</dd>
<dt><strong><code>reg_search</code></strong> :&ensp;<code>str</code></dt>
<dd>"grid", "pair", "add" or "mul".
"pair" for elementwise grid search in the case of several regularizers
"grid" for the fullgrid search in the case of several regularizers
"add" and "mul" for the ariphmetic and geometric progression
respectively for PerplexityStrategy
(Default value = "grid")</dd>
<dt><strong><code>use_relative_coefficients</code></strong> :&ensp;<code>bool</code></dt>
<dd>forces the regularizer coefficient to be in relative form
i.e. normalized over collection properties</dd>
<dt><strong><code>strategy</code></strong> :&ensp;<code>BaseStrategy</code></dt>
<dd>optimization approach (Default value = None)</dd>
<dt><strong><code>tracked_score_function</code></strong> :&ensp;<code>str</code> <code>ot</code> <code>callable</code></dt>
<dd>optimizable function for strategy (Default value = None)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>visualization flag (Default value = False)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RegularizationControllerCube(BaseCube):
    def __init__(self, num_iter: int, parameters,
                 reg_search=&#39;grid&#39;, use_relative_coefficients: bool = True, strategy=None,
                 tracked_score_function=None, verbose: bool = False, separate_thread: bool = True):
        &#34;&#34;&#34;
        Initialize stage. Checks params and update internal attributes.

        Parameters
        ----------
        num_iter : int
            number of iterations or method
        parameters : list[dict] or dict
            regularizers params
            each dict should contain the following fields: 
                (&#34;reg_name&#34; or &#34;regularizer&#34;),
                &#34;score_to_track&#34; (optional),
                &#34;tau_converter&#34;,
                &#34;user_value_grid&#34;
                See top-level docstring for details.
            Examples:

                    &gt;&gt;  {&#34;regularizer&#34;: artm.regularizers.&lt;...&gt;,
                    &gt;&gt;   &#34;score_to_track&#34;: &#34;PerplexityScore@all&#34;,
                    &gt;&gt;   &#34;tau_converter&#34;: &#34;prev_tau * user_value&#34;,
                    &gt;&gt;   &#34;user_value_grid&#34;: [0.5, 1, 2]}


            -----------

                    &gt;&gt;  {&#34;reg_name&#34;: &#34;decorrelator_for_ngramms&#34;,
                    &gt;&gt;   &#34;score_to_track&#34;: None,
                    &gt;&gt;   &#34;tau_converter&#34;: (
                    &gt;&gt;       lambda initial_tau, prev_tau, cur_iter, user_value:
                    &gt;&gt;       initial_tau * (cur_iter % 2) + user_value
                    &gt;&gt;   )
                    &gt;&gt;   &#34;user_value_grid&#34;: [0, 1]}

        reg_search : str
            &#34;grid&#34;, &#34;pair&#34;, &#34;add&#34; or &#34;mul&#34;. 
            &#34;pair&#34; for elementwise grid search in the case of several regularizers 
            &#34;grid&#34; for the fullgrid search in the case of several regularizers 
            &#34;add&#34; and &#34;mul&#34; for the ariphmetic and geometric progression
            respectively for PerplexityStrategy 
            (Default value = &#34;grid&#34;)
        use_relative_coefficients : bool
            forces the regularizer coefficient to be in relative form
            i.e. normalized over collection properties
        strategy : BaseStrategy
            optimization approach (Default value = None)
        tracked_score_function : str ot callable
            optimizable function for strategy (Default value = None)
        verbose : bool
            visualization flag (Default value = False)

        &#34;&#34;&#34;  # noqa: W291
        super().__init__(num_iter=num_iter, action=&#39;reg_controller&#39;,
                         reg_search=reg_search, strategy=strategy, verbose=verbose,
                         tracked_score_function=tracked_score_function,
                         separate_thread=separate_thread)
        self._relative = use_relative_coefficients
        self.data_stats = None
        self.raw_parameters = parameters
        if isinstance(parameters, dict):
            parameters = [parameters]
        self._convert_parameters(parameters)

    def _convert_parameters(self, all_parameters):
        &#34;&#34;&#34;

        Parameters
        ----------
        all_parameters : list of dict

        &#34;&#34;&#34;
        for params_dict in all_parameters:
            assert (&#34;reg_name&#34; in params_dict) != (&#34;regularizer&#34; in params_dict)
            if &#34;regularizer&#34; in params_dict:
                assert params_dict[&#34;regularizer&#34;].tau is not None

        self.parameters = [
            {
                &#34;object&#34;: {
                    &#34;reg_name&#34;: params_dict.get(&#34;reg_name&#34;, None),
                    &#34;regularizer&#34;: params_dict.get(&#34;regularizer&#34;, None),
                    &#34;score_to_track&#34;: params_dict.get(&#34;score_to_track&#34;, None),
                    &#34;tau_converter&#34;: params_dict[&#34;tau_converter&#34;],
                    &#34;local_dict&#34;: {&#34;user_value&#34;: None},
                    &#34;max_iters&#34;: params_dict.get(&#34;max_iters&#34;, self.num_iter)
                },
                &#34;field&#34;: &#34;callback&#34;,
                &#34;values&#34;: params_dict.get(&#39;user_value_grid&#39;, [0])
            }
            for params_dict in all_parameters
        ]

    def apply(self, topic_model, one_model_parameter, dictionary=None, model_id=None):
        &#34;&#34;&#34;
        Applies regularizers and controller agents to model

        Parameters
        ----------
        topic_model : TopicModel
        one_model_parameter : list or tuple
        dictionary : Dictionary
            (Default value = None)
        model_id : str
            (Default value = None)

        Returns
        -------
        TopicModel

        &#34;&#34;&#34;
        new_model = topic_model.clone(model_id)
        new_model.parent_model_id = topic_model.model_id

        modalities = dict()
        if self._relative:
            modalities = new_model.class_ids
            if self.data_stats is None:
                self.data_stats = count_vocab_size(dictionary, modalities)

        for (agent_blueprint_template, field_name, current_user_value) in one_model_parameter:
            agent_blueprint = dict(agent_blueprint_template)
            if agent_blueprint[&#34;reg_name&#34;] is None:
                regularizer = agent_blueprint[&#34;regularizer&#34;]
                new_regularizer = deepcopy(regularizer)
                handle_regularizer(
                    self._relative,
                    new_model,
                    new_regularizer,
                    self.data_stats,
                )
                agent_blueprint[&#34;reg_name&#34;] = new_regularizer.name
            else:
                if agent_blueprint[&#39;reg_name&#39;] not in new_model.regularizers.data:
                    error_msg = (f&#34;Regularizer {agent_blueprint[&#39;reg_name&#39;]} does not exist. &#34;
                                 f&#34;Cannot be modified.&#34;)
                    raise ValueError(error_msg)

            agent_blueprint[&#39;local_dict&#39;][&#39;user_value&#39;] = current_user_value
            # ControllerAgent needs only reg_name in constructor
            agent_blueprint.pop(&#34;regularizer&#34;)
            agent = ControllerAgent(**agent_blueprint)
            new_model.callbacks.append(agent)
        return new_model

    def get_jsonable_from_parameters(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        jsonable_parameters = []

        for one_model_parameters in self.raw_parameters:
            one_jsonable = dict(one_model_parameters)
            converter = one_model_parameters[&#39;tau_converter&#39;]

            if not isinstance(converter, str):
                try:
                    # not always works, but this is not important
                    one_jsonable[&#34;tau_converter&#34;] = str(getsource(converter))
                except (TypeError, OSError):
                    # OSError: may arise if working in Jupyter Notebook
                    one_jsonable[&#34;tau_converter&#34;] = &#34;&lt;NOT AVAILABLE&gt;&#34;

            jsonable_parameters.append(one_jsonable)

        return jsonable_parameters</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="topicnet.cooking_machine.cubes.base_cube.BaseCube" href="base_cube.html#topicnet.cooking_machine.cubes.base_cube.BaseCube">BaseCube</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, topic_model, one_model_parameter, dictionary=None, model_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Applies regularizers and controller agents to model</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>topic_model</code></strong> :&ensp;<code>TopicModel</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>one_model_parameter</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>Dictionary</code></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>model_id</code></strong> :&ensp;<code>str</code></dt>
<dd>(Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TopicModel</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def apply(self, topic_model, one_model_parameter, dictionary=None, model_id=None):
    &#34;&#34;&#34;
    Applies regularizers and controller agents to model

    Parameters
    ----------
    topic_model : TopicModel
    one_model_parameter : list or tuple
    dictionary : Dictionary
        (Default value = None)
    model_id : str
        (Default value = None)

    Returns
    -------
    TopicModel

    &#34;&#34;&#34;
    new_model = topic_model.clone(model_id)
    new_model.parent_model_id = topic_model.model_id

    modalities = dict()
    if self._relative:
        modalities = new_model.class_ids
        if self.data_stats is None:
            self.data_stats = count_vocab_size(dictionary, modalities)

    for (agent_blueprint_template, field_name, current_user_value) in one_model_parameter:
        agent_blueprint = dict(agent_blueprint_template)
        if agent_blueprint[&#34;reg_name&#34;] is None:
            regularizer = agent_blueprint[&#34;regularizer&#34;]
            new_regularizer = deepcopy(regularizer)
            handle_regularizer(
                self._relative,
                new_model,
                new_regularizer,
                self.data_stats,
            )
            agent_blueprint[&#34;reg_name&#34;] = new_regularizer.name
        else:
            if agent_blueprint[&#39;reg_name&#39;] not in new_model.regularizers.data:
                error_msg = (f&#34;Regularizer {agent_blueprint[&#39;reg_name&#39;]} does not exist. &#34;
                             f&#34;Cannot be modified.&#34;)
                raise ValueError(error_msg)

        agent_blueprint[&#39;local_dict&#39;][&#39;user_value&#39;] = current_user_value
        # ControllerAgent needs only reg_name in constructor
        agent_blueprint.pop(&#34;regularizer&#34;)
        agent = ControllerAgent(**agent_blueprint)
        new_model.callbacks.append(agent)
    return new_model</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="topicnet.cooking_machine.cubes.base_cube.BaseCube" href="base_cube.html#topicnet.cooking_machine.cubes.base_cube.BaseCube">BaseCube</a></b></code>:
<ul class="hlist">
<li><code><a title="topicnet.cooking_machine.cubes.base_cube.BaseCube.get_jsonable_from_parameters" href="base_cube.html#topicnet.cooking_machine.cubes.base_cube.BaseCube.get_jsonable_from_parameters">get_jsonable_from_parameters</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#fields">Fields</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="topicnet.cooking_machine.cubes" href="index.html">topicnet.cooking_machine.cubes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="topicnet.cooking_machine.cubes.controller_cube.is_score_out_of_control" href="#topicnet.cooking_machine.cubes.controller_cube.is_score_out_of_control">is_score_out_of_control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent" href="#topicnet.cooking_machine.cubes.controller_cube.ControllerAgent">ControllerAgent</a></code></h4>
<ul class="">
<li><code><a title="topicnet.cooking_machine.cubes.controller_cube.ControllerAgent.invoke" href="#topicnet.cooking_machine.cubes.controller_cube.ControllerAgent.invoke">invoke</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube" href="#topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube">RegularizationControllerCube</a></code></h4>
<ul class="">
<li><code><a title="topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube.apply" href="#topicnet.cooking_machine.cubes.controller_cube.RegularizationControllerCube.apply">apply</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>